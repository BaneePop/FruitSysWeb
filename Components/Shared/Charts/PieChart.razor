@using Microsoft.JSInterop
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

<div class="chart-container">
    <canvas id="@CanvasId" width="@Width" height="@Height"></canvas>
</div>

@code {
    [Parameter] public string CanvasId { get; set; } = Guid.NewGuid().ToString();
    [Parameter] public int Width { get; set; } = 300;
    [Parameter] public int Height { get; set; } = 200;
    [Parameter] public Dictionary<string, decimal>? Data { get; set; }
    [Parameter] public string Title { get; set; } = "";
    [Parameter] public string[] Colors { get; set; } = new[] { 
        "rgba(255, 99, 132, 0.8)",
        "rgba(54, 162, 235, 0.8)",
        "rgba(255, 205, 86, 0.8)",
        "rgba(75, 192, 192, 0.8)",
        "rgba(153, 102, 255, 0.8)"
    };

    private bool _isRendered = false;
    private bool _isDisposed = false;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _isRendered = true;
            if (Data?.Any() == true)
            {
                await CreateChart();
            }
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        if (_isRendered && Data?.Any() == true && !_isDisposed)
        {
            await CreateChart();
        }
    }

    private async Task CreateChart()
    {
        if (!_isRendered || _isDisposed) return;
        
        try
        {
            var labels = Data?.Keys.ToArray() ?? Array.Empty<string>();
            var values = Data?.Values.ToArray() ?? Array.Empty<decimal>();

            if (!labels.Any()) return;

            var config = new
            {
                type = "pie",
                data = new
                {
                    labels = labels,
                    datasets = new[]
                    {
                        new
                        {
                            label = Title,
                            data = values,
                            backgroundColor = Colors.Take(labels.Length).ToArray(),
                            borderColor = Colors.Take(labels.Length).Select(c => c.Replace("0.8", "1")).ToArray(),
                            borderWidth = 1
                        }
                    }
                },
                options = new
                {
                    responsive = true,
                    maintainAspectRatio = false,
                    plugins = new
                    {
                        title = new
                        {
                            display = !string.IsNullOrEmpty(Title),
                            text = Title
                        },
                        legend = new
                        {
                            display = true,
                            position = "right"
                        }
                    }
                }
            };

            await JSRuntime.InvokeVoidAsync("ChartJsInterop.updateChart", CanvasId, config);
        }
        catch (JSDisconnectedException)
        {
            // Circuit is disconnected - this is expected when user closes tab/refreshes
            // Do nothing, no logging needed
        }
        catch (ObjectDisposedException)
        {
            // Component is disposed - this is expected during navigation/disposal
            // Do nothing, no logging needed
        }
        catch (InvalidOperationException ex) when (
            ex.Message.Contains("statically rendered") || 
            ex.Message.Contains("circuit has disconnected") ||
            ex.Message.Contains("being disposed"))
        {
            // Silent fail za prerendering i disconnect greške
            // Do nothing, no logging needed
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error creating pie chart: {ex.Message}");
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (_isDisposed) return;
        
        _isDisposed = true;
        
        if (_isRendered)
        {
            try
            {
                // Pokušaj da pozoveš JSInterop, ali ignoriši sve greške povezane sa disconnect
                await JSRuntime.InvokeVoidAsync("ChartJsInterop.destroyChart", CanvasId);
            }
            catch (JSDisconnectedException)
            {
                // Circuit je disconnect - ovo je normalno kada se zatvara tab/refresh
                // Nema potrebe za logging
            }
            catch (ObjectDisposedException)
            {
                // Component je dispose - ovo je normalno tokom navigation
                // Nema potrebe za logging
            }
            catch (InvalidOperationException ex) when (
                ex.Message.Contains("circuit has disconnected") || 
                ex.Message.Contains("statically rendered") ||
                ex.Message.Contains("being disposed"))
            {
                // Silent fail za disconnect/dispose greške
                // Nema potrebe za logging
            }
            catch (TaskCanceledException)
            {
                // Task je cancelled - ovo se dešava tokom dispose
                // Nema potrebe za logging
            }
            catch
            {
                // Sve ostale greške ignoriši bez logging-a
                // Chart će biti očišćen automatski kada se stranica unload-uje
            }
        }
    }
}

<style>
    .chart-container {
        position: relative;
        width: 100%;
        height: 100%;
    }
</style>
